package org.example;

import java.util.List;

public class EventSourcedCalculator {
    private static final int MAX_STATE_VALUE = 10_000;
    private static final int MIN_STATE_VALUE = 0;

    // this is state to be modified
    public record State(double value) {}

    // these are the commands that we can issue to the command handler function for now, ie this is the domain of the
    // commands handler function
    public sealed interface Command permits
            AddCommand,
            SubtractCommand,
            MultiplyCommand,
            DivideCommand {}
    public record AddCommand(double value) implements Command {}
    public record SubtractCommand(double value) implements Command {}
    public record MultiplyCommand(double value) implements Command {}
    public record DivideCommand(double value) implements Command {}

    // these are all the event that is processed by the event handler.
    public sealed interface Event permits
            ValueAddedEvent,
            ValueSubtractedEvent,
            ValueMultipliedEvent,
            ValueDividedEvent,
            ErrorEvent {}
    public record ValueAddedEvent(double value) implements Event {}
    public record ValueSubtractedEvent(double value) implements Event {}
    public record ValueMultipliedEvent(double value) implements Event {}
    public record ValueDividedEvent(double value) implements Event {}
    public record ErrorEvent(String reason) implements Event {}

    // this is the command handler than validates the incoming commands and products only valid event ie range of this function
    // is the domain of the event handler function
    public static Event handleCommand(final State state, final Command command) {
        return switch (command) {
            case AddCommand(double value)  -> new ValueAddedEvent(Math.min(MAX_STATE_VALUE - state.value(), value));
            case SubtractCommand(double value) -> new ValueSubtractedEvent(Math.max(MIN_STATE_VALUE, state.value() - value));
            case MultiplyCommand(double value) when state.value() * value > MAX_STATE_VALUE -> new ErrorEvent("mul_failed");
            case MultiplyCommand(double value) -> new ValueMultipliedEvent(value);
            case DivideCommand(double value) when value == 0 -> new ErrorEvent("divide_failed");
            case DivideCommand(double value) -> new ValueDividedEvent(value);
            case null -> new ErrorEvent("command is null");
        };
    }

    // this is the function that handles all the events generated by the command handler
    public static State handleEvent(final State state, final Event result) {
        return switch (result) {
            case ValueAddedEvent(double value)      -> new State(state.value() + value);
            case ValueSubtractedEvent(double value) -> new State(state.value() - value);
            case ValueMultipliedEvent(double value) -> new State(state.value() * value);
            case ValueDividedEvent(double value)    -> new State(state.value() / value);
            case ErrorEvent(String reason) -> {
                System.out.println("Error -> " + reason);
                yield state;
            }
        };
    }

    public static State process(final State state, final Command command) {
        return handleEvent(state, handleCommand(state, command));
    }

    public static State processAll(final State initial, final List<Command> commands) {
        var current = initial;
        for (final Command cmd : commands) { current = process(current, cmd); }
        return current;
    }

    public static void main(String[] args) {
        final State initial = new State(0);

        List<Command> commands = List.of(
                new AddCommand(10),
                new AddCommand(50),
                new DivideCommand(0),
                new AddCommand(2)
        );

        final State result = EventSourcedCalculator.processAll(initial, commands);
        System.out.println(result);

        final State result2 = EventSourcedCalculator.process(initial, null);
        System.out.println(result2);
    }
}
